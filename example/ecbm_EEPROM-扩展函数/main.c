/*
***********************************************************************************************
*例程名    ：片内EEPROM扩展函数
*作者      ：奈特
*库函数版本：V2.2.6-5
*限定芯片  ：无，STC8系列都行。本例使用STC8A8K64S4A12。
*限定频率  ：无，STCISP提供的频率都行。本例使用24MHz。
*例程说明  ：1.可以在ecbm_core.h里设置你使用的单片机型号，然后再次编译并下载。这个型号一定要选对，否则
			操作EEPROM的时候，会算错地址。
			2.本例程主要用了EEPROM库和UART库，通过串口反馈EEPROM的信息。
			3.本例程用到了串口，波特率在uart.h里可以设置。
*BUG反馈   ：进Q群778916610，@群主并提供完整代码截图。
***********************************************************************************************
*/
#include "ecbm_core.h"	//加载库函数的头文件。
void main(){			//main函数，必须的。
	u8 dat;
	system_init();		//系统初始化函数，也是必须的。
	eeprom_init();		//初始化内部EEPROM。
	dat=22;
	eeprom_write_ex(0,&dat,1); //用扩展写函数向地址0,写入数据22。扩展函数需要提前在eeprom.h里的图形化界面里使能扩展函数才行，同时ram会多占用512字节。
	//作为和深入理解篇的对比，我们还是先写22再写82。
	dat=82;
	eeprom_write_ex(0,&dat,1); 
	//因为扩展函数都是对数组的多字节操作，所以得先定义一个变量，然后取变量地址做为参数给写函数。
	while(1){
		delay_ms(1000);//串口不要发送太频繁，否则串口助手会卡住。这里延时1秒。
		dat=0;//清零。
		eeprom_read_ex(0,&dat,1);//读取地址0的数据。
		debug("%u\r\n",(u16)dat);//debug函数其实就是调用了printf函数，而printf在C51里不支持显示u8型，所以要转换成u16型。
		//可以看到串口收到的数据是82，这是因为扩展函数里划了512字节的缓存对EEPROM里相同扇区没修改的部分做了备份。然后擦除、写入要写的数据，最后把备份的数据写回来。
		//这样就能把片内EEPROM当成真正的EEPROM来用了。
	}
}